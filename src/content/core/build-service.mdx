---
title: Okteto Build service
description: The Okteto Build service allows you to build your container images remotely
sidebar_label: Okteto Build service
id: build-service
---

import Image from "@theme/Image";


Every time you build your images with Okteto, your build is executed in a remote [BuildKit](https://github.com/moby/buildkit) server running in your cluster, deployed automatically by Okteto.
The image is also pushed to the [Okteto Registry](core/container-registry.mdx).
The following image illustrates this process:

<p align="center">
  <Image
    src={require("@site/static/img/buildkit.png").default}
    alt="Buildkit architecture"
    width="850"
  />
</p>

The Okteto Build service addresses common issues that often slow down image builds such as limited local resources, inefficient emulation, and the lack of reusing images and cache layers already computed by other team members.

## How to build your images

The Okteto CLI is automatically configured to interact with the Okteto Build service (follow our docs to [install and configure the Okteto CLI](get-started/install-okteto-cli.mdx)).
For example, if your have the following Okteto Manifest:

```yaml title="okteto.yaml"
build:
  api:
    context: api
    dockerfile: Dockerfile
    args:
      GO_VERSION: 1.20
```

The command `okteto build` will build and push the **api** image to the Okteto Registry using the Okteto Build service:

```bash
okteto build
```

```bash
 i  Using cindy @ okteto.example.com as context
 i  Building 'api/Dockerfile' in tcp://buildkit.okteto.example.com:443...
 ...
 ✓  Image 'registry.okteto.example.com/cindy/api:okteto' successfully pushed
```

Read our documentation about the [`build` section](reference/okteto-manifest.mdx#build-object-optional) and the [`okteto build` command](reference/okteto-cli.mdx#build) for more information.

## Dockerfile Compatibility

Okteto Build is compatible with Dockerfile syntax. We leverage BuildKit's full capabilities, so any valid Dockerfile will work seamlessly with the Okteto Build service.

### Mount Cache ID Management

The only difference in Okteto Build compared to standard Docker behavior is how we manage the default ID for [mount caches](https://docs.docker.com/build/cache/optimize/#use-your-package-manager-wisely).

**Docker's default behavior:**
- The default cache ID is based solely on the target path
- Example: `RUN --mount=type=cache,target=/go/pkg/mod` uses `/go/pkg/mod` as the cache ID

**Okteto's default behavior:**
- The default cache ID is based on the target path **and** the current git repository name
- Example: For repository `myapp`, the same mount would use `myapp-/go/pkg/mod` as the cache ID

This difference ensures that different repositories using the same target folder don't accidentally share the same cache, which could lead to unexpected behavior or conflicts.

### Sharing Caches Between Repositories

If you want to explicitly share caches between different repositories, you can manually set the cache ID:

```dockerfile
# Explicitly set a cache ID to share between repositories
RUN --mount=type=cache,target=/go/pkg/mod,id=shared-go-cache \
    go mod download

# Or share npm cache across multiple projects
RUN --mount=type=cache,target=/root/.npm,id=shared-npm-cache \
    npm ci
```

For more information about mount caches and cache optimization, see the [official Docker documentation on build cache](https://docs.docker.com/build/cache/optimize/#use-your-package-manager-wisely).

## Smart Builds

Buildkit comes with a local cache to reuse cache layers between image builds.
You can configure the [Buildkit cache size and storage class](self-hosted/helm-configuration.mdx#buildkit) when installing Okteto to optimize the BuildKit cache behavior.

But the Buildkit cache has its own limitations. Even if every Dockerfile instruction is cached, you might wait 1 or 2 minutes until your build context is sent to Buildkit, Buildkit pulls your base image, detects that each Dockerfile instruction can be cached, and push the final image again to the Okteto Registry.

Smart Builds is an Okteto's feature designed to solve this problem.
For each image you build, Okteto computes a `hash` based on the build context and the rest of build parameters.
Okteto uses this hash to detect if the image has been already built by any other developer. If the image was already built, the build is skipped and the previous image is reused almost immediately.

Smart Builds are implemented by pushing a tag with the value of the `hash` to the namespace `okteto` in the Okteto Registry.
For example, if you build the following image:

```yaml title="okteto.yaml"
build:
  api:
    context: api
    dockerfile: Dockerfile
    args:
      GO_VERSION: 1.20
```

```bash
okteto build
```

```bash
 i  Using cindy @ okteto.example.com as context
 i  Building 'api/Dockerfile' in tcp://buildkit.okteto.example.com:443...
 ...
 => pushing manifest for registry.okteto.example.com/okteto/api:09f8e
 ✓  Image 'registry.okteto.example.com/cindy/api:okteto' successfully pushed
```

As you can see in the following image, the image is pushed to `okteto/api:09f8e`:

<p align="center">
  <Image
    src={require("@site/static/img/smart-builds-hash.png").default}
    alt="Smart builds"
    width="850"
  />
</p>


Also, `cindy/api:okteto` is re-tagged to `okteto/api:09f8e` to remember the last build performed in a given namespace.
The following image illustrates this process:

<p align="center">
  <Image
    src={require("@site/static/img/smart-builds-cindy.png").default}
    alt="Smart builds"
    width="850"
  />
</p>

If another user, **David**, builds the same image with the same build context and parameters, the same hash `09f8e` is computed.

```bash
okteto build
```

```bash
 i  Using david @ okteto.example.com as context
 i  Okteto Smart Builds is skipping build of "api" because it's already built
```

Smart builds detects that the tag `okteto/api:09f8e` already exists and skips the build.
Instead, the image `david/api:okteto` is re-tagged to `okteto/api:09f8e` to remember the last build performed in the David's namespace:

<p align="center">
  <Image
    src={require("@site/static/img/smart-builds-david.png").default}
    alt="Smart builds"
    width="850"
  />
</p>

### Prerequisite: Git environment required

Smart Builds needs access to a git repository to compute the content hash correctly. It uses more than just the branch and commit; it also inspects diffs, untracked files, and folder content to determine whether a build can be skipped.

**Environment variables are not enough:** setting `OKTETO_GIT_BRANCH` or `OKTETO_GIT_COMMIT` manually will not enable Smart Builds without an actual git repository present.

**Using Compose or commands in `deploy`:** when your manifest runs Okteto CLI commands that trigger image builds (for example, under `deploy: commands:` running `okteto deploy -f compose.yml`), ensure the `.git` directory is not excluded by `.oktetoignore`. Otherwise, Smart Builds cannot access git metadata and will fall back to a full build.

### Limitations with explicit image tags

Smart Builds are automatically disabled when you explicitly define the `image` field with a custom tag in your build configuration. Smart Builds work by generating a SHA based on your git repository status and using that SHA as the image tag. When you specify your own image tag, Smart Builds cannot determine if the build should be skipped.

**Examples that will NOT use Smart Builds:**
```yaml
build:
  api:
    # Explicit image tag disables Smart Builds
    image: "registry.okteto.example.com/${OKTETO_NAMESPACE}/movies-api:custom"
    context: api
    dockerfile: Dockerfile
```

**Examples that WILL use Smart Builds:**
```yaml
build:
  api:
    # No image field specified - Smart Builds enabled
    context: api
    dockerfile: Dockerfile
    args:
      GO_VERSION: 1.20
```

## Skipping Smart Builds behavior

You can force the build of your images and skip the Smart Build optimization by running the following command:

```bash
okteto build --no-cache
```

```bash
 i  Using cindy @ okteto.example.com as context
 i  Building 'api/Dockerfile' in tcp://buildkit.okteto.example.com:443...
 ...
 => pushing manifest for registry.okteto.example.com/okteto/api:09f8e
 ✓  Image 'registry.okteto.example.com/cindy/api:okteto' successfully pushed
```

The `--no-cache` flag will also disable the Buildkit local cache.

You can also disable Smart Builds by setting the environment variable `OKTETO_SMART_BUILDS_ENABLED=false`.
If you define `OKTETO_SMART_BUILDS_ENABLED=false` as an [Admin Variable](admin/dashboard.mdx#admin-variables), Smart Builds is disabled for all the image builds for all developers in your organization.
Admin variables are equivalent to defining that variable on every developer's machine.

## Build Queue System

:::info
Enable the build queue by setting the `OKTETO_BUILD_QUEUE_ENABLED` [feature flag](reference/feature-flags.mdx) to `true`.
:::

Okteto implements a build queue system to ensure consistent build performance and fair resource distribution across your development teams. When you execute a build command, Okteto automatically routes your build to the Okteto Build pod with the lowest resource utilization based on real-time metrics (CPU pressure, memory usage, and IOPS).

If all Okteto Build pods are busy (exceeding configured resource thresholds), your build request enters a queue and waits until a build pod becomes ready.
This happens when builds finish and resources are freed, or when new build pods are created through the Okteto Build [Horizontal Pod Autoscaler](self-hosted/manage/buildkit-high-performance.mdx#4-enable-hpa-to-optimize-performance-and-costs).

The Build Queue System ensures that builds have consistent performance by preventing Okteto Build pods from being overloaded during high-demand periods.
Administrators can monitor Okteto Build performance, configure resource thresholds, and fine-tune the build queue behavior through the [Build Service admin dashboard](admin/build-service.mdx).

### Queue Wait Experience

When all Okteto Build pods are busy, the Okteto CLI will wait for an available build pod before starting your build. During this time, you'll see clear messages indicating your position in the queue and the waiting status. The CLI automatically retries with exponential backoff to minimize unnecessary requests while ensuring your build starts as soon as resources become available.

If the wait time exceeds the configured timeout (default 10 minutes), the build will fail with an error message suggesting you contact your Okteto administrators to increase the number of Okteto Build instances or adjust the resource threshold configuration. You can configure this timeout by setting the `OKTETO_BUILDKIT_QUEUE_WAIT_TIMEOUT` environment variable (e.g., `OKTETO_BUILDKIT_QUEUE_WAIT_TIMEOUT=15m`).

## Advanced timeouts configuration

The following environment variables can be useful for handling timeouts from the Okteto CLI when communicating with the Okteto Build Service.
You can configure them as [Admin Variables](admin/dashboard.mdx#admin-variables) if needed:

- `OKTETO_KEEPALIVE_CLIENT_TIME_MS`: After this duration of time, if the client doesn't see any activity it will ping the server to see if the transport is still alive. If set below 10s, a minimum value of 10s will be used (default value is infinity.)
- `OKTETO_KEEPALIVE_CLIENT_TIMEOUT_MS`: After sending a keepalive ping, the client waits for this duration of time and if no activity is seen even after that the connection is closed. (default value is 20 seconds.)
- `OKTETO_KEEPALIVE_CLIENT_PERMIT_WITHOUT_STREAM`: If `true`, the client sends keepalive pings even with no active RPCs. If `false`, when there are no active RPCs, Time and Timeout will be ignored and no keepalive pings will be sent (defaults to `false`.)
